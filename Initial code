/* **********************************
* Author:   Michael O'Donnell 
*           mo14776@my.bristol.ac.uk
*
*   Basic calculator
*   (+-/*^)
*************************************/






#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main()
{
    /* **********
    *   BIDMAS Precedence
    *
    *   Brackets-1
    *   Indices-2
    *   Division-3
    *   Multiplication-3
    *   Addition-4
    *   Subtraction-4
    **********************/


    char input[100],stack[100], functionOutput[100], *inputString;

    printf("Enter equation\n");
    fgets(input, sizeof(input),stdin);
    double numberOutput[100], working[2];
    int numberOutputCounter=0;
    int functionOutputCounter=0;
    int stackCounter=0;
    int hold;
    inputString=input;
    while(*inputString!='\n' && *inputString!='\0')
    {
        if(isdigit(*inputString))
        {
            numberOutput[numberOutputCounter]=strtod(inputString,&inputString);
            numberOutputCounter++;
        }
        else
        {
            switch(*inputString)
            {
            case '(': stack[stackCounter]=*inputString; stackCounter++; break;       //Assign input and move to new empty input

            case ')':{  if(stackCounter>0)                                                  //Prevents stack underflow
                        {
                            stackCounter--;                                                 //Return counter to the last input
                            while(stack[stackCounter]!='(')
                            {
                                functionOutput[functionOutputCounter]=stack[stackCounter];                  //Pop top input onto output stack and advance output stack
                                functionOutputCounter++;
                                if(stackCounter>=0)                                         //Prevents underflow of stack
                                {
                                    stackCounter--;                                         //Current input has been popped, therefore advance back one step to previous input
                                }
                                else{ printf("Non-Paired brackets.\n");break;}
                            }

                            break;                                                          //If '(' is encountered the stack counter does not move. Allows overwrite of '('
                        }
                        else{stack[stackCounter]=*inputString; stackCounter++; break;}
                    }


            case '^':stack[stackCounter]=*inputString; stackCounter++; break;       //Assign input and move to new empty input

            case '/':
            case '*':{
                        if(stackCounter>0)                                                  //Prevents stack underflow
                        {
                            stackCounter--;                                                 //Return counter to the last input
                            switch(stack[stackCounter])
                            {
                            case '-':
                            case '+':{
                                        stackCounter++;                                     //Advance Counter to empty cell
                                        stack[stackCounter]=*inputString;            //Input into cell and advance
                                        stackCounter++;
                                        break;
                                     }
                            case '*':
                            case '/':
                            case '^':{                                                      //equal precedence and left associative
                                        functionOutput[functionOutputCounter]=stack[stackCounter];          //Pop '/' to output and advance output counter
                                        functionOutputCounter++;
                                        stack[stackCounter]=*inputString;            //Push '/' onto stack and advance stack Counter
                                        stackCounter++;
                                        break;
                                     }
                            default : ;stack[stackCounter]=*inputString; stackCounter++; break;
                            }

                        }
                        else{stack[stackCounter]=*inputString; stackCounter++; break;}
                        break;
                    }
            case '+':
            case '-': {
                        if(stackCounter>0)                                                  //Prevents stack underflow
                        {
                            stackCounter--;                                                 //Return counter to the last input
                            switch(stack[stackCounter])
                            {
                            case '-':
                            case '+':
                            case '*':
                            case '/':
                            case '^':{
                                        functionOutput[functionOutputCounter]=stack[stackCounter];          //Pop '*' to output and advance output counter
                                        functionOutputCounter++;
                                        stack[stackCounter]=*inputString;                    //Push '/' onto stack and advance stack Counter
                                        stackCounter++;
                                        break;
                                     }
                            default : stackCounter++;stack[stackCounter]=*inputString; stackCounter++; break;
                            }

                        }
                        else{stack[stackCounter]=*inputString; stackCounter++; break;}
                        break;
                    }
            default : break;


            }
            inputString++;                                                              // advances the input string pointer to the next character
        }

        while(functionOutputCounter>0)
        {
            functionOutputCounter--;                                                // selects last function to be entered
            numberOutputCounter--;                                                  // selects last number to be entered
            working[1]=numberOutput[numberOutputCounter];
            numberOutputCounter--;
            working[0]=numberOutput[numberOutputCounter];

            switch(functionOutput[functionOutputCounter])
            {
            case '+':{
                        numberOutput[numberOutputCounter]=working[0]+working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '-':{
                        numberOutput[numberOutputCounter]=working[0]-working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '*':{
                        numberOutput[numberOutputCounter]=working[0]*working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '/':{
                        numberOutput[numberOutputCounter]=working[0]/working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '^':{
                        numberOutput[numberOutputCounter]=pow(working[0],working[1]);        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            }
        }
    }
    stackCounter--;
    for(stackCounter;stackCounter>=0;stackCounter--)
    {
        functionOutput[functionOutputCounter]=stack[stackCounter];
        functionOutputCounter++;
    }
    hold=functionOutputCounter;
    functionOutputCounter=0;
    while(hold>0 )
        {
            hold--;
            numberOutputCounter--;                                                  // selects last number to be entered
            working[1]=numberOutput[numberOutputCounter];
            numberOutputCounter--;
            working[0]=numberOutput[numberOutputCounter];

            switch(functionOutput[functionOutputCounter])
            {
            case '+':{
                        numberOutput[numberOutputCounter]=working[0]+working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '-':{
                        numberOutput[numberOutputCounter]=working[0]-working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '*':{
                        numberOutput[numberOutputCounter]=working[0]*working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '/':{
                        numberOutput[numberOutputCounter]=working[0]/working[1];        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            case '^':{
                        numberOutput[numberOutputCounter]=pow(working[0],working[1]);        // overwrites the number and advances 1. equivalent of popping 2 off the stack and pushing one on.
                        numberOutputCounter++;
                        break;
                    }
            }
            functionOutputCounter++;
        }

    int i;

    for(i=0;i<numberOutputCounter;i++)
    {
        printf("%lf",numberOutput[i]);
    }
    return(0);
}
